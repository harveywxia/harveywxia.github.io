{"posts":[{"title":"SpaCy基于规则的匹配--TokenMatcher","content":"基于规则的匹配 查找短语和单词，并匹配实体 在原始文本上使用正则表达式匹配，spaCy的基于规则的匹配器引擎和组件不仅可以找到所需的单词和短语，还可以让您访问文档中的词及其相互关系。这意味着您可以轻松访问和分析周围的词，将跨度合并为单个词或加入到doc.ents中的命名实体中。 我应该使用规则还是训练一模型模型？ 对于复杂的任务，通常最好训练一个基于统计的命名实体识别模型。但是，统计模型需要训练数据，因此在许多情况下，基于规则的方法更实用。在项目初始阶段尤其如此：你可以使用基于规则的方法作为数据收集过程的一部分，以帮助您“引导”统计模型。 如果您有一些示例并且希望您的系统能够基于这些示例进行泛化（generalize），那么就应该训练模型。如果在当前上下文有线索，它会更加有效。例如，如果您尝试检测人名或公司名称，您的应用程序可能会受益于统计命名实体识别模型。 如果你想在数据中查找有限数量的示例，那么基于规则的系统就是一个很好的选择，或者你可以找到一个词规则或者正则表达式来准确的表达一个模式 。例如，你可以通过基于规则的方法很好地处理国家名称、IP地址或URL等。 您还可以将这两种方法结合使用，可以使用规则改进统计模型，以处理非常具体的情况并提高准确性。有关详细信息，请参阅基于规则的实体识别部分。 什么时候应该使用词匹配器(Matcher)和短语匹配器？ 如果你已经拥有一个大型术语列表或一个由单个或多个token语组成的地名录，此时你想找到一个确切的实例，那么PhraseMacher就非常有用。 从spaCy v2.1.0开始，您还可以通过LOWER属性进行快速且不区分大小写的匹配。 Matcher没有PhraseMatcher那么快，因为他会比较所有token的属性。但是，它允许你使用模型预测的词汇属性和语言特征为正在寻找的tokens编写一个非常抽象的表示。例如，你可以查找一个跟在“love”或“like”动词后，或可选限定符或者一个不少于10个字符的token后的名词， Token-based匹配 spaCy自带规则匹配引擎Matcher, 对tokens的操作类似于正则表达式。规则可以引用token注释（例如标记text或tag_，或者如IS_PUNCT的标志）。规则匹配器还允许您传入自定义回调以处理匹配项 - 例如，可以合并实体和应用自定义标签。您还可以将模式与实体ID相关联，以允许进行一些基本的实体链接或消歧。要匹配大型术语列表，您可以使用 PhraseMatcher，它接受Doc对象作为匹配模式。 添加模式 假设我们想让 spaCy 找到三个token的组合： 小写形式与“hello”匹配的token，例如“Hello”或“HELLO”。 is_punct标记设置为True的标记，即任何标点符号。 小写形式与“world”匹配的标记，例如“World”或“WORLD”。 [{&quot;LOWER&quot;: &quot;hello&quot;}, {&quot;IS_PUNCT&quot;: True}, {&quot;LOWER&quot;: &quot;world&quot;}] !!!重要的提示 在编写模式时，记住每个字典代表一个token。如果 spaCy 的分词处理与模式中定义的token不匹配，则该模式不会产生任何结果。在开发复杂模式时，请确保根据 spaCy 的标记化检查示例： doc = nlp(&quot;A complex-example,!&quot;) print([token.text for token in doc]) 首先，我们用一个词汇来初始化Matcher。匹配器必须始终与其操作的文档共享相同的词汇。我们现在可以调用matcher.add()并传入一个ID和一个模式列表作为参数。 spaCy v 3.0 · Python 3 基于 Binder import spacy from spacy.matcher import Matcher nlp = spacy.load(&quot;en_core_web_sm&quot;) matcher = Matcher(nlp.vocab) # Add match ID &quot;HelloWorld&quot; with no callback and one pattern pattern = [{&quot;LOWER&quot;: &quot;hello&quot;}, {&quot;IS_PUNCT&quot;: True}, {&quot;LOWER&quot;: &quot;world&quot;}] # 将会匹配到“hello”+“标点”+“world” matcher.add(&quot;HelloWorld&quot;, [pattern]) doc = nlp(&quot;Hello, world! Hello world!&quot;) matches = matcher(doc) for match_id, start, end in matches: string_id = nlp.vocab.strings[match_id] # Get string representation span = doc[start:end] # The matched span print(match_id, string_id, start, end, span.text) 结果： 15578876784678163569 HelloWorld 0 3 Hello, world 匹配器返回一个(match_id, start, end)元组的列表——在本例中就是[('15578876784678163569', 0, 3)]，它映射到我们原始文档的doc[0:3]。该match_id是字符串ID的“HelloWorld”的散列值的。要获取字符串值，你可以在StringStore中查询。 for match_id, start, end in matches: string_id = nlp.vocab.strings[match_id] # 'HelloWorld' span = doc[start:end] # The matched span 或者，我们还可以选择添加多个模式，例如，还可以匹配“hello”和“world”之间没有标点符号的序列： patterns = [ [{&quot;LOWER&quot;: &quot;hello&quot;}, {&quot;IS_PUNCT&quot;: True}, {&quot;LOWER&quot;: &quot;world&quot;}], [{&quot;LOWER&quot;: &quot;hello&quot;}, {&quot;LOWER&quot;: &quot;world&quot;}] ] matcher.add(&quot;HelloWorld&quot;, patterns) 默认情况下，匹配器将只返回匹配项而不执行任何其他操作，例如合并实体或分配标签。这完全取决于您，你可以通过向add()函数传入不同的回调函数作为on_match参数来单独定义每个模式。这很有用，因为它允许您编写完全自定义和模式特定的逻辑。例如，您可能希望将一些模式合并为一个token，同时为其他模式类型添加实体标签。这个时候你不必为每个进程创建不同的匹配器。 可用的token属性 可用的Token模式键对应于许多 Token 属性. 基于规则的匹配支持的属性有： ATTRIBUTE DESCRIPTION ORTH 准确的Token逐字文本. TYPE:str TEXT 准确的Token逐字文本. TYPE:str LOWER Token文本的小写形式.TYPE:str LENGTH Token文本的长度.TYPE:int IS_ALPHA, IS_ASCII, IS_DIGIT Token文本由字母字符、ASCII 字符、数字组成.TYPE:bool IS_LOWER, IS_UPPER, IS_TITLE Token文本是小写、大写、标题.TYPE:bool IS_PUNCT, IS_SPACE, IS_STOP Token文本是标点符号、空格、停止词.TYPE:bool IS_SENT_START Token是句子的开始.TYPE:bool LIKE_NUM, LIKE_URL, LIKE_EMAIL Token文本类似于数字、URL、电子邮件.TYPE:bool SPACY Token有一个结尾空格.TYPE:bool POS, TAG, MORPH, DEP, LEMMA, SHAPE 令牌的简单和扩展词性标签、形态分析、依赖标签、词根、形状（shape）。请注意，这些属性的值区分大小写。有关可用词性标签和依赖项标签的列表，请参阅注释规范。 TYPE:str ENT_TYPE Token的实体标签。 TYPE:str _ 自定义扩展属性的属性. TYPE:Dict[str, Any] OP 运算符和量词，限定Token模式的匹配次数。TYPE:str 属性名称区分大小写吗？ 不区分。spaCy会进行名称规范化处理，{&quot;LOWER&quot;: &quot;text&quot;}和{&quot;lower&quot;: &quot;text&quot;}会得到相同的结果。使用大写版本主要是一种约定，以明确这些属性是“特殊的”并且不完全映射到像Token.lower和Token.lower_这样的标记属性 。 为什么不支持所有Token属性？ spaCy无法提供对所有属性的访问，因为Matcher循环遍历Cython数据，而不是Python对象。在匹配器内部，我们正在处理一个TokenC struct – 我们没有Token实例. 这意味着所有引用计算属性的属性都无法访问。 大写的属性名称类似于LOWER或IS_PUNCT引用自spacy.attrs枚举表。它们被传递到一个本质上是一个大case/switch语句的函数中，以确定要返回的结构字段。相同的属性标识符用于Doc.to_array，以及代码中需要描述此类字段的其他一些地方。 提示：试用交互式匹配器 匹配器演示 该交互式匹配器通过创建基于规则的匹配起并在你的文本上运行他们来测试你的的Matcher。每个Token可以设置多个属性，如文本值、词性标记或布尔标志。基于token的视图可以让你看到spaCy是如何处理您的文本的，以及为什么可以成功匹配，或者为什么无法匹配。 扩展模式语法和属性 Token模式也可以映射到属性字典，而不仅仅是映射到单个值。例如，指定词根的值应该是值列表的一部分，或设置最小字符长度。可用的属性如下表： 例子 # Matches &quot;love cats&quot; or &quot;likes flowers&quot; pattern1 = [{&quot;LEMMA&quot;: {&quot;IN&quot;: [&quot;like&quot;, &quot;love&quot;]}}, {&quot;POS&quot;: &quot;NOUN&quot;}] # Matches tokens of length &gt;= 10 pattern2 = [{&quot;LENGTH&quot;: {&quot;&gt;=&quot;: 10}}] # Match based on morph attributes pattern3 = [{&quot;MORPH&quot;: {&quot;IS_SUBSET&quot;: [&quot;Number=Sing&quot;, &quot;Gender=Neut&quot;]}}] # &quot;&quot;, &quot;Number=Sing&quot; and &quot;Number=Sing|Gender=Neut&quot; will match as subsets # &quot;Number=Plur|Gender=Neut&quot; will not match # &quot;Number=Sing|Gender=Neut|Polite=Infm&quot; will not match because it's a superset 属性 描述 IN 属性值是列表的成员。TYPE:Any NOT_IN 属性值不是列表的成员。TYPE:Any IS_SUBSET 属性值（用于MORPH或自定义列表属性）是列表的子集。TYPE:Any IS_SUPERSET 属性值（用于MORPH或自定义列表属性）是列表的超集。TYPE:Any INTERSECTS 属性值（用于MORPH或自定义列表属性）与列表具有非空交集。 Any ==, &gt;=, &lt;=, &gt;, &lt;| 属性值等于、大于或等于、小于或等于、大于或小于。TYPE:Union[int, float] 常用表达式 在某些情况下，仅匹配token和token属性是不够的——例如，你可能希望匹配一个单词的不同拼写，而想为每个拼写添加新模式。 pattern = [{&quot;TEXT&quot;: {&quot;REGEX&quot;: &quot;^[Uu](\\.?|nited)$&quot;}}, {&quot;TEXT&quot;: {&quot;REGEX&quot;: &quot;^[Ss](\\.?|tates)$&quot;}}, {&quot;LOWER&quot;: &quot;president&quot;}] 该REGEX操作允许你为任何属性定义规则，包括自定义属性。它始终需要应用于像TEXT,LOWER或TAG 之类的属性： # Match different spellings of token texts pattern = [{&quot;TEXT&quot;: {&quot;REGEX&quot;: &quot;deff?in[ia]tely&quot;}}] # Match tokens with fine-grained POS tags starting with 'V' pattern = [{&quot;TAG&quot;: {&quot;REGEX&quot;: &quot;^V&quot;}}] # Match custom attribute values with regular expressions pattern = [{&quot;_&quot;: {&quot;country&quot;: {&quot;REGEX&quot;: &quot;^[Uu](nited|\\.?) ?[Ss](tates|\\.?)$&quot;}}}] !!!重要的提示 使用REGEX运算符时，请记住它对单个标记token而不是整个文本进行操作。每个表达式都将匹配一个token。如果您需要对整个文本进行匹配，请参阅有关对整个文本进行正则表达式匹配的详细信息 。 全文匹配正则表达式 如果您的表达式适用于多个标记，一个简单的解决方案是匹配doc.textwithre.finditer并使用 Doc.char_spanSpan从匹配的字符索引创建 a 的方法。如果匹配的字符没有映射到一个或多个有效Token，则Doc.char_span返回None。 什么是有效的令牌序列？ 在该示例中，表达式也将匹配&quot;US&quot;在&quot;USA&quot;。但是， &quot;USA&quot;是单个标记，而Span对象是Token序列。所以 &quot;US&quot;不能是它自己的span，因为它没有在token边界上结束。 import spacy import re nlp = spacy.load(&quot;en_core_web_sm&quot;) doc = nlp(&quot;The United States of America (USA) are commonly known as the United States (U.S. or US) or America.&quot;) expression = r&quot;[Uu](nited|\\.?) ?[Ss](tates|\\.?)&quot; for match in re.finditer(expression, doc.text): start, end = match.span() span = doc.char_span(start, end) # This is a Span object or None if match doesn't map to valid token sequence if span is not None: print(&quot;Found match:&quot;, span.text) 结果 Found match: United States Found match: United States Found match: U.S. Found match: US 如何将match扩展为有效的令牌序列？ 在某些情况下，您可能希望将匹配扩展到最近的token边界，你就需要为 &quot;USA&quot;创建一个span，即使只子串&quot;US&quot;会被匹配。您可以使用文档中tokens的字符偏移量（Token.idx](https://spacy.io/api/token#attributes)）来计算它，可作为 .。这样你就可以个创建一个列表包含有效token的开始和结束边界，并给你留下一个基础的算法问题：给定一个数字，找到下一个最小数（token开始）或下一个最大数（token结束）。这将是最接近有效token的边界。 有很多实现方法，最直接的方法是在Doc中创建一个基于字符的字典表，索引到所在的token中。它易于编写且不易出错，并为您提供恒定的查找时间：您只需为每个Doc创建一次词典。 chars_to_tokens = {} for token in doc: for i in range(token.idx, token.idx + len(token.text)): chars_to_tokens[i] = token.i 然后，您可以在给定位置查找字符，并获取该字符所属的相应token的索引。你的span就是doc[token_start:token_end]。 如果字符不在dict中，则意味着它是（white）空格token被拆分的。不过，这希望不应该发生，因为这意味着您的正则表达式正在生成包含前导或后续空格的匹配项。 span = doc.char_span(start, end) if span is not None: print(&quot;Found match:&quot;, span.text) else: start_token = chars_to_tokens.get(start) end_token = chars_to_tokens.get(end) if start_token is not None and end_token is not None: span = doc[start_token:end_token + 1] print(&quot;Found closest match:&quot;, span.text) 运算符和量词 匹配器还允许您使用指定为'OP'键的量词。量词让您定义要匹配的token序列，例如一个或多个标点符号，或指定可选token。请注意，不能使用嵌套或作用域量词——你可以使用on_match回调来实现。 OP运算符 描述 ! 否定模式，要求它精确匹配 0 次。 ? 使模式可选，允许它匹配 0 次或 1 次 +｜要求模式匹配 1 次或多次。 *｜ 允许模式匹配零次或多次。 pattern = [{&quot;LOWER&quot;: &quot;hello&quot;}, {&quot;IS_PUNCT&quot;: True, &quot;OP&quot;: &quot;?&quot;}] ","link":"https://harveywxia.github.io/post/spacy-ji-yu-gui-ze-de-pi-pei-tokenmatcher/"},{"title":"Github搭建个人主页","content":"概述 GitHub Pages可以用来托管个人静态网站，便于用来实现博客。 准备工作 Gthub账号 域名(可选) Github Pages 新建一个仓库，命名格式如下： {用户明}.github.io 需要选择public（公开） 进入到该仓库的setting菜单（在star下面）中。可以选择并开启。 此时在浏览器中即可访问页面，但是如果想更好的管理，可以使用Gridea。 Gridea Gridea是一个静态博客写作客户端，所有文件都在本地，没有数据库，实现简单，支持Markdown。 官网下载Gridea，安装并进入设置页面 域名与仓库名一样,分支填master,email自己填,这里说一下Token.打开设置中的开发者设置: 右上角头像--&gt;Settings --&gt;Developer settings --&gt;Personal access tokens--&gt;Generate token 勾选repo然后复制token即可。 参考资料 Github Pages+Gridea搭建个人博客 「Gridea」给初接触者的一些使用技巧 ","link":"https://harveywxia.github.io/post/github-da-jian-ge-ren-zhu-ye/"},{"title":"Redmine配置","content":"问题状态 问题状态标签：新建问题、新建、进行中、已解决、反馈、已关闭、已拒绝、挂起。 redmine添加自定义问题状态 跟踪标签 跟踪标签：里程碑、任务、需求用例、功能、缺陷 项目中各跟踪标签的结构关系 说明： 1． 5个里程碑：需求分析、概要设计、功能开发、系统测试、系统部署 2． 在“需求分析”、“概要设计”、“系统测试”、“部署上线” 这几个里程碑中主要是以“任务”的形式指派给项目成员 3． “功能开发”这个里程碑中有涉及到“需求用例”“功能”“任务”“缺陷” 4. 若功能划分的不够细，则可将其以任务的形式再次划分。 ","link":"https://harveywxia.github.io/post/redmine-pei-zhi/"},{"title":"CentOS7安装redmine","content":"简介 Redmine是用Ruby开发的基于web的项目管理软件，是用ROR框架开发的一套跨平台项目管理系统，通过“项目（Project）”的形式把成员、任务（问题）、文档、讨论以及各种形式的资源组织在一起，大家参与更新任务、文档等内容来推动项目的进度，同时系统利用时间线索和各种动态的报表形式来自动给成员汇报项目进度。 安装流程 docker环境安装 卸载旧版本 较旧的 Docker 版本称为 docker 或 docker-engine 。如果已安装这些程序，请卸载它们以及相关的依赖项。 $ sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine 安装docker 依赖环境 yum-utils 提供了 yum-config-manager ，并且 device mapper 存储驱动程序需要 device-mapper-persistent-data 和 lvm2。 $ sudo yum install -y yum-utils \\ device-mapper-persistent-data \\ lvm2 安装 Docker Engine-Community 安装最新版本的 Docker Engine-Community 和 containerd. $ sudo yum install docker-ce docker-ce-cli containerd.io 启动 Docker $ sudo systemctl start docker 测试 通过运行 hello-world 映像来验证是否正确安装了 Docker Engine-Community 。 $ sudo docker run hello-world 运行以上命令会打印出hello-world。 安装docker-compose 这里选择使用pip安装，pip的安装过程这里不展开。 使用pip安装时建议使用virtulenv，运行以下命令安装： pip install docker-compose 如果你不使用virtulenv，则需要运行以下命令，完成安装。 sudo pip install docker-compose 测试 docker-compose -version 会打印出相关版本信息。 参考 Install Docker Compose 安装redmine version: '3' services: redmine: image: redmine:4.1.1-alpine restart: always ports: - '8080:3000' environment: REDMINE_DB_MYSQL: mysql REDMINE_DB_PASSWORD: redminemysql REDMINE_SECRET_KEY_BASE: supersecretkey volumes: - '/usr/harvey/docker/redmine/redmine_dir:/usr/src/redmine/files' mysql: image: mysql:8.0.20 restart: always environment: MYSQL_ROOT_PASSWORD: redminemysql MYSQL_DATABASE: redmine volumes: - '/usr/harvey/docker/redmine/mysql__dir:/var/lib/mysql' 参考 dockerhub-redmine 测试 浏览器中输入以下网址， http://localhost:8080/login 进入登录界面，默认用户名/密码：admin/admin 开始你的redmine之旅吧。 ","link":"https://harveywxia.github.io/post/centos7-an-zhuang-redmine/"},{"title":"Django rest framework 使用笔记  ","content":"models层 models field 在model中添加字段的格式一般为： field_name = field_type(**field_options) field options(所有字段共用) null 默认为False，True则表示可以为null。（空字符串在数据库中可能被存储为''）。 blank 默认为False，True表示可以为空。 choice 可选的，限制了该选项的字段值必须是所指定的choice中的一个。 from django.db import models class Student(models.Model): FRESHMAN = 'FR' SOPHOMORE = 'SO' JUNIOR = 'JR' SENIOR = 'SR' YEAR_IN_SCHOOL_CHOICES = ( (FRESHMAN, 'Freshman'), #第一个参数是真正的model参数，#第二个参数则是方便人们理解阅读 (SOPHOMORE, 'Sophomore'), (JUNIOR, 'Junior'), (SENIOR, 'Senior'), ) year_in_school = models.CharField( max_length=2, choices=YEAR_IN_SCHOOL_CHOICES, default=FRESHMAN, ) def is_upperclass(self): return self.year_in_school in (self.JUNIOR, self.SENIOR) db_column: 数据库column名称。默认为本字段的名称; db_index: 如果为True的话，该字段的数据库索引将会被创建; default: 设置该字段的默认值，可以是值也可以是对象; editable: 默认为True，若为False，则不会在admin界面显示; primary_key: 若设置为True，则表示将该字段设置为主键。一般情况下django默认会设置一个自增长的id主键; unique: 若设置为True，该字段值不可重复. field type(字段类型) models基础字段 AutoField() 根据已有id自增长的整形唯一字段，一般每个model类不需设置该字段，因为django会为每个model自动设置。 django默认会为每个model类添加如下语句： id = models.AutoField(primary_key=True) 当其他字段添加了primary_key属性，则不会创建id字段了,每个model类仅能有一个主键. BooleanField() 布尔型字段，默认的表单窗口部件是CheckBoxInput CharField() 字符型字段，默认的表单窗口部件是TextInput。该字段类型有一个必需参数： max_length 在数据库水平限定了字符串最大长度 DateField() 日期字段，字段的值是python中datetime.date的实例，默认的表单窗口是TextInput有几个可选的参数： auto_now=True/False: 当设置为True时，每当该对象使用save()时，该字段的值就会被更新。 auto_now_add=True/False: 当设置为True时，该字段的值为该对象被创建时的日期 DateTimeField() 日期和时间字段，值为datetime.datetime实例。默认的表单窗口以及可选参数同上。 DecimalField() 混合精度的小数型数字字段。有两个必需的参数： max_digits=ingt_number:限定数字的最大位数（包含小数位） decimal_places=int_number:存储数字的小数位 #to store numbers up to 999 with a resolution of 2 decimal places, you’d use models.DecimalField(..., max_digits=5, decimal_places=2) EmailField(max_length=254, **options) 邮件字段，使用EmailValidator进行验证 FileField(upload_to=None, max_length=100, **options) 文件上传字段。这个字段不能设置primary_key和unique选项.在数据库中存储类型是varchar，默认最大长度为100. 有两个可选参数： upload_to: 如果使用默认的FileSystomStorage，文件将会存储到settings文件中配置的MEDIA_ROOT路径中。upload_to的值也可以为可调用对象,通过调用这个对象可以获得上传路径。 instance=: 定义了FileField的模型实例 filename='': 文件名称。 class MyModel01(models.Model): # file will be uploaded to MEDIA_ROOT/uploads upload = models.FileField(upload_to='uploads/') # or... # file will be saved to MEDIA_ROOT/uploads/2015/01/30 upload = models.FileField(upload_to='uploads/%Y/%m/%d/') #upload_to=可调用对象 def user_directory_path(instance, filename): # file will be uploaded to MEDIA_ROOT/user_&lt;id&gt;/&lt;filename&gt; return 'user_{0}/{1}'.format(instance.user.id, filename) class MyModel02(models.Model): upload = models.FileField(upload_to=user_directory_path) storage 用来设定文件存储仓库 FilePathField(path=None, match=None, recursive=False, max_length=100, **options) 这个字段的值被限制在系统上某个目录中的所有文件名集合中。有三个参数: path='': 该参数必需。上行所说的'某个目录’的绝对路径。Example: &quot;/home/images&quot;. match='pattern': 可选参数。格式是正则表达式。用来拣选符合匹配正则表达式的文件 recursive=True/False: 可选参数，默认为False。设定是否递归该目录下所有子目录的所有文件。 FilePathField(path=&quot;/home/images&quot;, match=&quot;foo.*&quot;, recursive=True) FloatField() 浮点字段，默认的表单窗口部件是NumberInput。和DecimalField经常混淆不清，FloatField在内部使用Python中的float对象，而DecimalField在内部使用Python中的decimal对象。 ImageField(upload_to=None, height_field=None, width_field=None, max_length=100, **options) 图像字段。继承了FileField的所有属性和方法。而且还能自动验证上传的对象是否为合法的图像。 IntegerField() 整型字段。 GenericIPAddressField(protocol='both', unpack_ipv4=False, **options) ip地址字段 protocol='both/ipv4/ipv6': 默认为both unpack_ipv4: 用处不大。 NullBooleanField() 类似于BooleanField，不同的是其允许值为null TextField() 与CharField类似，但一般用来存储体积较大的文本。 TimeField(auto_now=False, auto_now_add=False, **options)` 时间字段，其值为datetime.time实例 URLField(max_length=200, **options)URL字段, 类似于CharField`的子类，默认最大长度为200. UUIDField(**options)通用唯一标识字段，当不想用django默认设置的AutoField`字段时，可以用该字段代替。 关系字段 1. 一对一： 现在有很多一对一辅导班，也就是上课时，一个老师对应一个学生，一个学生对应一个老师 2. 多对一： 很多偏远山区的学校可能整个学校只有一个老师，这一个老师对应多个学生，所有的学生对应这一个老师 3. 多对多： 而我们则很幸福，学校里有许多老师，一个老师教习一科，学生有多个老师，老师有多个学生。 ForeignKey(othermodel, on_delete, **options) 用于多对一或者一对多或者外键字段: othermodel： 所关联的模型，'多' model使用外键关联 '一'model。 当所关联的模型为他自己时，使用'self'; 当引用的模型为其他app中的模型时，要加上app名称标签: 'app_name.model_name'; 数据库会自动在外键字段上创建索引，可以使用de_index=False关闭该功能。 on_delete： 当删除 &quot;一&quot; 模型对象时，django会根据该参数的值对与该对象相关联的其他对象(也就是 '多’)进行操作。 在django1.9以及之前的版本中，on_delete作为一个关键字参数。而在1.10则可以作为第二个参数 models.CASCADE： 默认为models.CASCADE 级联删除。当删除'一'时，'多’会被删除。比如： # mysite项目下名为polls的app中的models.py class follower(models.Model): name = models.CharField(max_length=200) menpai = models.ForeignKey('menpai', on_delete=models.CASCADE) #定义了models.CASCADE属性 def __str__(self): return self.name class menpai(models.Model): name = models.CharField(max_length=200) def __str__(self): return self.name #运行 python3 manager.py shell进入交互页面 &gt;&gt;&gt; from polls.models import follower,menpai &gt;&gt;&gt; m1=menpai(name='huashanpai') &gt;&gt;&gt; m1.save() &gt;&gt;&gt; m2=menpai(name='riyuejiao') &gt;&gt;&gt; m2.save() &gt;&gt;&gt; f1=follower(name='linghuchong',menpai=m1) &gt;&gt;&gt; f1.save() &gt;&gt;&gt; f2=follower(name='renwoxing',menpai=m2) &gt;&gt;&gt; f2.save() &gt;&gt;&gt; f1.menpai &lt;menpai: huashanpai&gt; &gt;&gt;&gt; m1.delete() (2, {'polls.menpai': 1, 'polls.follower': 1}) # 删除华山派时，将令狐冲也删除了 modles.PROTECT : 当删除一个具有外键关系的对象时，会引发一个异常，阻止删除该对象 models.SET_NULL: 设置删除对象所关联的外键字段为null。但字段的null属性必需为True models.SET_DEFAULT : 设置删除对象所关联的外键字段为默认的值。 models.SET(value)：设置删除对象所关联的对象的外键字段为value,value也可以是一个可调用函数。 from django.conf import settings from django.contrib.auth import get_user_model from django.db import models def get_sentinel_user(): return get_user_model().objects.get_or_create(username='deleted')[0] class MyModel(models.Model): user = models.ForeignKey( settings.AUTH_USER_MODEL, on_delete=models.SET(get_sentinel_user), ) models.DO_NOTHING: 不做任何操作 limit_choices_to: 限制该字段为选项形。格式：limit_choices_to={'is_staff': True}。值也可以为可调用函数。 def limit_pub_date_choices(): return {'pub_date__lte': datetime.date.utcnow()} limit_choices_to = limit_pub_date_choices related_name 设置从关联对象到自身的关系的名称，若值为'+' 则关联对象与自身无逆向关系。详解请看官方文档。举例： related_name的作用是在反向引用的时候，就是通过User去找Employee的时候，用User.user_employee，引文关键词叫：reverse accessor。 class Employee(generic.BO): user = models.OneToOneField(User,verbose_name=_(&quot;登录账户&quot;),blank=True,null=True,on_delete=models.CASCADE,related_name='user_employee') to_field 设置所关联对象的关联字段。默认为关联对象的主键字段。 OneToOneField和ForeignKey有什么区别 ManyToManyField(othermodel, **options) 多对多字段。 othermodel: 所关联的model名称; db_table: 多对多关系会在两个模型所对应的表中间创建一个'中间表’ ，将多对多转换为两个多对一，该选项为这个中间表设置名称。一般来说django会默认为中间表创建名称，但人们读起来可能搞不清楚究竟中间表关联到了哪里; related_name: 同多对一字段中的related_name; limite_choices_to: 同....; symmetrical: 当多对多关联对象为自身时可能会用到的参数。默认为True。a,b同属于person模型，person中的friends字段与自身设置了多对多关系，当该值设置为True时，django假定关系为对称，即：a是b的朋友，那么b也是a的朋友。设置为False时，django会强制为逆向关系创建描述信息; though: 不想让django自动创建中间表，手动创建中间表所对应的model，通过though指定对应的model名称; though_field: 当though参数被使用时，该参数才会有效。指定使用哪些中间模型字段来确立两个模型的多对多关系; OneToOneField(othermodel, on_delete, parent_link=False, **options) 一对一字段。 othermodel: ....... on_delete:........ related_name:........... 参考资料 Fail to POST OneToOneField with Django REST 参考 关联 关联未定义的Model 如果你要与某个尚未定义的model建立关联，就使用model的名称，而不是使用model对象本身。 class Book(models.Model): pub = models.ForeignKey('Publisher') 关联自身 可以与自身建立多对一或者一对一关系。 class People(models.Model): name=models.CharField(max_length=20) leader=models.ForeignKey('self',blank=True,null=True) class Person(models.Model): friends = models.ManyToManyField(&quot;self&quot;) //通过shell添加关系 &gt;&gt;&gt;p1.friends.add(p2,p3) 默认情况下，这种关联关系是对称的，如果person1是person2的朋友，那么person2也是person1的朋友，要查找person2的所有朋友可以直接使用person2.friends.all()。 如果要取消这种对称关系，可以将symmetrical设置为False： class Person2(models.Model): friends=models.ManyToManyField(&quot;self&quot;,symmetrical=False) 这样查询p3的朋友，就需要p3.person_set.all()了 反向名称related_name 反向名称用来从被关联字段指向关联字段。 class Book(models.Model): name=models.CharField(max_length=20) pub=models.ForeignKey(Publisher,related_name='pub') authors=models.ManyToManyField(Author,related_name='author') 这样用Publisher或者Author反向查询Book时可以用related_name了:publisher1.pub.all()或者author1.author.all()。 如果不想设置反向关心，则设置related_name为'+'或者以'+'结束。 user = models.ForeignKey(User, related_name='+') 如果有多个ManyToManyField指向同一个Model，这样反向查询FOO_set的时候就无法弄清是哪个ManyToManyField字段了，所以可以禁止反向关系： users = models.ManyToManyField(User, related_name='u+') referents = models.ManyToManyField(User, related_name='ref+') 参考 认证和权限 settings.py设置默认的认证方式和权限。 REST_FRAMEWORK = { # 全局，默认认证 'DEFAULT_AUTHENTICATION_CLASSES': ( 'rest_framework.authentication.SessionAuthentication', 'rest_framework.authentication.BasicAuthentication', # 'rest_framework.authentication.TokenAuthentication', ), # 全局，默认权限 'DEFAULT_PERMISSION_CLASSES': ( 'rest_framework.permissions.IsAuthenticated', ), } django-rest-auth django-rest-auth用户管理app，网址 用户管理 登陆 /rest-auth/login/ (POST) username email password Returns Token key 登出 /rest-auth/logout/ (POST) 重置密码 /rest-auth/password/reset/ (POST) email 确认密码 /rest-auth/password/reset/confirm/ (POST) uid token new_password1 new_password2 Note:uid和token是请求重置密码接口/rest-auth/password/reset/返回的 修改密码 /rest-auth/password/change/ (POST) new_password1 new_password2 old_password 查询用户信息 /rest-auth/user/ (GET, PUT, PATCH) username first_name last_name Returns pk, username, email, first_name, last_name 注册 /rest-auth/registration/ (POST) username password1 password2 email 确认 /rest-auth/registration/verify-email/ (POST) key 自定义用户认证 BaseAuthentication类： django rest-framework 通过BaseAuthentication 实现认证功能,无论是自定义的认证类还是rest-framework自带的认证类都应该继承BaseAuthentication.BaseAuthentication 中有两个方法authenticate和authenticate_header,其中authenticate方法必须实现 如果用户需要自定义认证方法则继承BaseAuthentication重写authenticate方法即可. 新建UserToken 修改models.py文件，增减UserToken类，其中UserInfo也可使用系统的User类，具体如下： from django.db import models class UserInfo(models.Model): user_type_choices = ( (1, '普通用户'), (2, 'VPI'), (3, 'SVPI'), ) user_type = models.IntegerField(choices=user_type_choices) username = models.CharField(max_length=32, unique=True) password = models.CharField(max_length=64) class UserToken(models.Model): user = models.OneToOneField('UserInfo', models.CASCADE) token = models.CharField(max_length=64) 构建认证代码 打开APP_DIR/utils/auth.py（若无，则新建该文件），将认证代码放入其中。 from rest_framework import exceptions from rest_framework.authentication import BaseAuthentication from app01 import models # 实现自定义的认证类 class Authtication(BaseAuthentication): def authenticate(self, request): # 这儿的 request 对象不是 django 原生的 request 而是 rest_framework 内部进行封装过的 request # 使用 request._request 调用 django 原生的 request 对象 token = request._request.GET.get('token') # 检查用户的 token 是否合法 token_obj = models.UserToken.objects.filter(token=token).first() if not token_obj: # rest_framework 会在内部捕捉这个异常并返回给用户认证失败的信息 raise exceptions.AuthenticationFailed('用户认证失败') # 在 rest_framework 内部会将这两个字段赋值给request以供后续调用 return (token_obj.user, token_obj) 修改views.py文件 from django.http import JsonResponse from rest_framework.views import APIView from app01.utils.auth import Authtication import hashlib import time # 生成 token 字符串 def md5(user): ctime = str(time.time()) m = hashlib.md5(bytes(user, encoding='utf-8')) m.update(bytes(ctime, encoding='utf-8')) return m.hexdigest() # 用户登录 class AuthView(APIView): def post(self, request): ret = {'code':1000, 'msg':None} try: user = request._request.POST.get('username') pwd = request._request.POST.get('password') obj = models.UserInfo.objects.filter(username=user, password=pwd).first() if not obj: ret['code'] = 1001 ret['msg'] = &quot;用户名或密码错误&quot; # 为登录用户创建token token = md5(user) #存在更新 不存在创建 models.UserToken.objects.update_or_create(user=obj, defaults={'token':token}) ret['token'] = token except: ret['code'] = 1002 ret['msg'] = '请求异常' return JsonResponse(ret) # 业务代码 class Order(APIView): # 注册自定义的认证类, 可以有多个, 从左到右进行认证匹配 authentication_classes = [Authtication,] def get(self, request): # request.user 这个值等于 Authtication 返回的元组的第一个值 # request.auth 这个值等于 Authtication 返回的元组的第二个值 ret = {'code':1000, 'msg':None, 'data':None} ret['data'] = '欢迎使用本系统' return JsonResponse(ret) rest_framework内置的认证类： BasicAuthentication # 基于浏览器实现的 Basic 认证, ftp 使用网页登录时使用的就是 Basic 认证 SessionAuthentication # 基于 django 的 user.is_active 进行认证 TokenAuthentication # 简单的基于 token 的认证 RemoteUserAuthentication # 简单的远程用户认证实现 可参考文档： Django 认证系统 配置全局生效的认证类和匿名用户： 自定义的认证类如果每次都在指定的类中使用authentication_classes指定,就有可能出现大量的重复代码。我们可以通过全局设置让指定的认证类对继承自APIView的所有类生效，修改settings.py文件。 REST_FRAMEWORK = { # 设置全局生效的认证类(可以有多个) # app01 为 django app 的名称 # utils 为 app 目录下面的 utils 目录(这个目录必须包含 __init__.py 文件) # auth 为 utils 目录下面的 auth.py 文件 # Authtication 为 auth.py 文件里面的 Authtication 类 # 这儿的设置其实就是使用 from ... import ... 的路径 'DEFAULT_AUTHENTICATION_CLASSES': [&quot;app01.utils.auth.Authtication&quot;,], #匿名用户配置 'UNAUTHENTICATED_USER': None, # 设置匿名用户的用户名, 默认为 AnonymousUser, 使用 request.user 查看 'UNAUTHENTICATED_TOKEN': None, # 设置匿名用户的 token, 默认为 None, 使用 request.auth 查看 } 指定View类不使用全局的认证类： 在不使用全局认证类的View类中添加authentication_classes = []或者``authentication_classes = ['xxxx']` # authentication_classes = [] 表示不使用认证 # authentication_classes = ['xxxx'], xxxx 表示当前类需要使用的认证类用于替换全局类 参考链接 错误 Django Rest Framework - “detail”: “Not found.”` 遇到的情况是url被其他路由拦截。 Django：CSRF Failed: CSRF token missing or incorrect 登陆成功后一直返回Django：CSRF Failed: CSRF token missing or incorrect其实不是跨域问题，而是Django自带的用户验证机制导致，为此我们需要在请求头重添加X-CSRFToken,步骤如下：将Postman返回的cookie中的csrftoken值复制到请求头中， KEY VALUE X-CSRFToken cookie中的token值 之后提交请求即可。 官网链接 简化django的八个python包 参考资料 数据查询 django queryset 实现基本的增删改查等。 Django QuerySet 方法梳理 常用 Django QuerySet Api django_filter 实现定制化的查询功能，可对不同字段进行精确和模糊查询。 pypy官网 官方文档 用django-filter实现高级搜索 外键 serializer 自动序列化外键时会遇到一些问题。 参考文献 DRF 3 - Creating Many-to-Many update/create serializer with though table DRF: Simple foreign key assignment with nested serializers? manytomany 保存方式 # 直接保存多对多关系 def create(self, validated_data): if validated_data.get('help_poor'): help_poor_datas = validated_data.pop('help_poor') activity_arrangement = ActivityArrangement.objects.create(**validated_data) for help_poor_data in help_poor_datas: help_poor = HelpPoor.objects.create(**help_poor_data) activity_arrangement.help_poor.add(help_poor) else: activity_arrangement = ActivityArrangement.objects.create(**validated_data) return activity_arrangement 数据库 数据库连接 django连接mongodb数据库 参考文献 Django MongoDB Engine mongo数据库官方文档 model migrate 问题 django migrate error: table 'xxx' already exists 多为移库后，库表与migration文件不符造成，可以使用以下命令解决。 python manage.py migrate --fake &lt;appname&gt; 参考文献 参考 stack over flow 数据库迁移 slqlite3迁移mysql 数据库的迁移方法针对不同数据库，如 SQLite3, MySQL, PostgreSQL 之间数据迁移方案，以及数据在不同机器上迁移方案 简单的数据导出与导入（简单的迁移） django 项目提供了一个导出的方法 python manage.py dumpdata, 不指定 appname时默认为导出所有的app python manage.py dumpdata [appname] &gt; appname_data.json 比如我们有一个项目叫mysite, 里面有一个app叫blog,我们想导出blog的所有数据 python manage.py dumpdata blog &gt; blog_dump.json 数据导入,不需要指定appname python manage.py loaddata blog_dump.json ! ! ! 注意: 使用该方法解决问题，缺少表时手动添加库表 备注：一些常用的 python manage.py dumpdata auth &gt; auth.json # 导出用户数据 优点：可以兼容各种支持的数据库，也就是说，以前用的是SQLite3，可以导出后，用这种方法导入到MySQL, PostgreSQL等数据库，反过来也可以。 缺点：数据量大的时候，速度相对较慢，表的关系比较复杂的时候可以导入不成功。 如果你运气好的话可能会导入完成，但是往往不那么顺利，原因如下： a) 我们在写models的时候如果用到CharField,就一定要写max_length,在sqlite3中是不检查这个最大长度的，你写最大允许长度为100，你往数据库放10000个，sqlite3都不报错，而且不截断数据的长度，这似乎是slite3的优点，但是也给从sqlite3导入其它数据库带来了困难,因为MySQL和PostgreSQL数据库都会检查最大长度，超出时就报错！ b) Django 自带的contentType会导致出现一些问题 用上面的方法只迁移一个app应该问题不大，但是如果有用户，用户组挂钩，事情往往变得糟糕！如果导入后没有对数据进行修改，你可以考虑重新导入，可能还要快一些，如果是手动在后台输入或者修改过，这种方法就不适用了 参考文献 自强学堂 问题 Django 2.0 SQLite3 to MySQL loaddata error: “The database backend does not accept 0 as a value for AutoField.” //For illustration in datadump_3-7-18.json: [ { //&lt;----- I GOT DELETED &quot;model&quot;: &quot;inventory.bike&quot;, //&lt;----- I GOT DELETED &quot;pk&quot;: 0, //&lt;----- I GOT DELETED &quot;fields&quot;: { //&lt;----- I GOT DELETED //... //&lt;----- I GOT DELETED } //&lt;----- I GOT DELETED }, //&lt;----- I GOT DELETED { &quot;model&quot;: &quot;inventory.bike&quot;, &quot;pk&quot;: 1, &quot;fields&quot;: { //... } }, { &quot;model&quot;: &quot;inventory.bike&quot;, &quot;pk&quot;: 2, &quot;fields&quot;: { //... } } ] stackoverflow 从view到viewset django使用View， django-rest-framework(概念篇)——apiview&amp;viewset 分页 在drf中对于数据的返回支持多种分页技巧，在官网中主要向我们介绍了PageNumberPagination、LimitOffsetPagination、CursorPagination。 配置全局分页 采用全局配置需要在配置文件中设置，例如将全局分页设置为PageNumberPagination，需要在base.py中添加如下配置： REST_FRAMEWORK = { 'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination', 'PAGE_SIZE': 100 } 单独设置分页 如果需要对每个视图进行单独配置，需要设置ModelViewSet中的pagination_class值，示例如下： class MachineRoomViewSet(viewsets.ModelViewSet): &quot;&quot;&quot; 机房操作视图 &quot;&quot;&quot; queryset = MachineRoom.objects.all() serializer_class = MachineRoomSerializer pagination_class = PageNumberPagination 修改分页风格 如果你需要修改分页风格 ，系需要重写分页类，然后设置你需要修改的属性。 class LargeResultsSetPagination(PageNumberPagination): page_size = 1000 page_size_query_param = 'page_size' max_page_size = 10000 class StandardResultsSetPagination(PageNumberPagination): page_size = 100 page_size_query_param = 'page_size' max_page_size = 1000 # 然后在视图中使用.pagination_class属性调用该自定义类 class BillingRecordsView(generics.ListAPIView): queryset = Billing.objects.all() serializer_class = BillingRecordsSerializer pagination_class = LargeResultsSetPagination # 或者是在设置中修改DEFAULT_PAGINATION_CLASS REST_FRAMEWORK = { 'DEFAULT_PAGINATION_CLASS': 'apps.core.pagination.StandardResultsSetPagination' } pageNumberPagination使用方法 这个分页样式接受请求查询参数中的一个数字页面号。 GET https://api.example.org/accounts/?page=4 响应对象 HTTP 200 OK { &quot;count&quot;: 1023 &quot;next&quot;: &quot;https://api.example.org/accounts/?page=5&quot;, &quot;previous&quot;: &quot;https://api.example.org/accounts/?page=3&quot;, &quot;results&quot;: [ … ] } Django-restframework Pagination（分页） Django-rest-framework pagination ","link":"https://harveywxia.github.io/post/django-rest-framework-shi-yong-bi-ji/"},{"title":"Hello Gridea","content":"👏 欢迎使用 Gridea ！ ✍️ Gridea 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... Github Gridea 主页 示例网站 特性👇 📝 你可以使用最酷的 Markdown 语法，进行快速创作 🌉 你可以给文章配上精美的封面图和在文章任意位置插入图片 🏷️ 你可以对文章进行标签分组 📋 你可以自定义菜单，甚至可以创建外部链接菜单 💻 你可以在 Windows，MacOS 或 Linux 设备上使用此客户端 🌎 你可以使用 𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌 或 Coding Pages 向世界展示，未来将支持更多平台 💬 你可以进行简单的配置，接入 Gitalk 或 DisqusJS 评论系统 🇬🇧 你可以使用中文简体或英语 🌁 你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力 🖥 你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步 🌱 当然 Gridea 还很年轻，有很多不足，但请相信，它会不停向前 🏃 未来，它一定会成为你离不开的伙伴 尽情发挥你的才华吧！ 😘 Enjoy~ ","link":"https://harveywxia.github.io/post/hello-gridea/"}]}