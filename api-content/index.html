{"posts":[{"title":"Github搭建个人主页","content":"概述 GitHub Pages可以用来托管个人静态网站，便于用来实现博客。 准备工作 Gthub账号 域名(可选) Github Pages 新建一个仓库，命名格式如下： {用户明}.github.io 需要选择public（公开） 进入到该仓库的setting菜单（在star下面）中。可以选择并开启。 此时在浏览器中即可访问页面，但是如果想更好的管理，可以使用Gridea。 Gridea Gridea是一个静态博客写作客户端，所有文件都在本地，没有数据库，实现简单，支持Markdown。 官网下载Gridea，安装并进入设置页面 域名与仓库名一样,分支填master,email自己填,这里说一下Token.打开设置中的开发者设置: 右上角头像--&gt;Settings --&gt;Developer settings --&gt;Personal access tokens--&gt;Generate token 勾选repo然后复制token即可。 参考资料 Github Pages+Gridea搭建个人博客 「Gridea」给初接触者的一些使用技巧 ","link":"https://harveywxia.github.io/post/github-da-jian-ge-ren-zhu-ye/"},{"title":"Redmine配置","content":"问题状态 问题状态标签：新建问题、新建、进行中、已解决、反馈、已关闭、已拒绝、挂起。 redmine添加自定义问题状态 跟踪标签 跟踪标签：里程碑、任务、需求用例、功能、缺陷 项目中各跟踪标签的结构关系 说明： 1． 5个里程碑：需求分析、概要设计、功能开发、系统测试、系统部署 2． 在“需求分析”、“概要设计”、“系统测试”、“部署上线” 这几个里程碑中主要是以“任务”的形式指派给项目成员 3． “功能开发”这个里程碑中有涉及到“需求用例”“功能”“任务”“缺陷” 4. 若功能划分的不够细，则可将其以任务的形式再次划分。 ","link":"https://harveywxia.github.io/post/redmine-pei-zhi/"},{"title":"CentOS7安装redmine","content":"简介 Redmine是用Ruby开发的基于web的项目管理软件，是用ROR框架开发的一套跨平台项目管理系统，通过“项目（Project）”的形式把成员、任务（问题）、文档、讨论以及各种形式的资源组织在一起，大家参与更新任务、文档等内容来推动项目的进度，同时系统利用时间线索和各种动态的报表形式来自动给成员汇报项目进度。 安装流程 docker环境安装 卸载旧版本 较旧的 Docker 版本称为 docker 或 docker-engine 。如果已安装这些程序，请卸载它们以及相关的依赖项。 $ sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine 安装docker 依赖环境 yum-utils 提供了 yum-config-manager ，并且 device mapper 存储驱动程序需要 device-mapper-persistent-data 和 lvm2。 $ sudo yum install -y yum-utils \\ device-mapper-persistent-data \\ lvm2 安装 Docker Engine-Community 安装最新版本的 Docker Engine-Community 和 containerd. $ sudo yum install docker-ce docker-ce-cli containerd.io 启动 Docker $ sudo systemctl start docker 测试 通过运行 hello-world 映像来验证是否正确安装了 Docker Engine-Community 。 $ sudo docker run hello-world 运行以上命令会打印出hello-world。 安装docker-compose 这里选择使用pip安装，pip的安装过程这里不展开。 使用pip安装时建议使用virtulenv，运行以下命令安装： pip install docker-compose 如果你不使用virtulenv，则需要运行以下命令，完成安装。 sudo pip install docker-compose 测试 docker-compose -version 会打印出相关版本信息。 参考 Install Docker Compose 安装redmine version: '3' services: redmine: image: redmine:4.1.1-alpine restart: always ports: - '8080:3000' environment: REDMINE_DB_MYSQL: mysql REDMINE_DB_PASSWORD: redminemysql REDMINE_SECRET_KEY_BASE: supersecretkey volumes: - '/usr/harvey/docker/redmine/redmine_dir:/usr/src/redmine/files' mysql: image: mysql:8.0.20 restart: always environment: MYSQL_ROOT_PASSWORD: redminemysql MYSQL_DATABASE: redmine volumes: - '/usr/harvey/docker/redmine/mysql__dir:/var/lib/mysql' 参考 dockerhub-redmine 测试 浏览器中输入以下网址， http://localhost:8080/login 进入登录界面，默认用户名/密码：admin/admin 开始你的redmine之旅吧。 ","link":"https://harveywxia.github.io/post/centos7-an-zhuang-redmine/"},{"title":"Django rest framework 使用笔记  ","content":"models层 models field 在model中添加字段的格式一般为： field_name = field_type(**field_options) field options(所有字段共用) null 默认为False，True则表示可以为null。（空字符串在数据库中可能被存储为''） blank 默认为False，True表示可以为空。 choice 可选的，限制了该选项的字段值必须是所指定的choice中的一个。 from django.db import models class Student(models.Model): FRESHMAN = 'FR' SOPHOMORE = 'SO' JUNIOR = 'JR' SENIOR = 'SR' YEAR_IN_SCHOOL_CHOICES = ( (FRESHMAN, 'Freshman'), #第一个参数是真正的model参数，#第二个参数则是方便人们理解阅读 (SOPHOMORE, 'Sophomore'), (JUNIOR, 'Junior'), (SENIOR, 'Senior'), ) year_in_school = models.CharField( max_length=2, choices=YEAR_IN_SCHOOL_CHOICES, default=FRESHMAN, ) def is_upperclass(self): return self.year_in_school in (self.JUNIOR, self.SENIOR) db_column: 数据库column名称。默认为本字段的名称; db_index: 如果为True的话，该字段的数据库索引将会被创建; default: 设置该字段的默认值，可以是值也可以是对象; editable: 默认为True，若为False，则不会在admin界面显示; primary_key: 若设置为True，则表示将该字段设置为主键。一般情况下django默认会设置一个自增长的id主键; unique: 若设置为True，该字段值不可重复. field type(字段类型) models基础字段 AutoField() 根据已有id自增长的整形唯一字段，一般每个model类不需设置该字段，因为django会为每个model自动设置。 django默认会为每个model类添加如下语句： id = models.AutoField(primary_key=True) 当其他字段添加了primary_key属性，则不会创建id字段了,每个model类仅能有一个主键. BooleanField() 布尔型字段，默认的表单窗口部件是CheckBoxInput CharField() 字符型字段，默认的表单窗口部件是TextInput。该字段类型有一个必需参数： max_length 在数据库水平限定了字符串最大长度 DateField() 日期字段，字段的值是python中datetime.date的实例，默认的表单窗口是TextInput有几个可选的参数： auto_now=True/False: 当设置为True时，每当该对象使用save()时，该字段的值就会被更新。 auto_now_add=True/False: 当设置为True时，该字段的值为该对象被创建时的日期 DateTimeField() 日期和时间字段，值为datetime.datetime实例。默认的表单窗口以及可选参数同上。 DecimalField() 混合精度的小数型数字字段。有两个必需的参数： max_digits=ingt_number:限定数字的最大位数（包含小数位） decimal_places=int_number:存储数字的小数位 #to store numbers up to 999 with a resolution of 2 decimal places, you’d use models.DecimalField(..., max_digits=5, decimal_places=2) EmailField(max_length=254, **options) 邮件字段，使用EmailValidator进行验证 FileField(upload_to=None, max_length=100, **options) 文件上传字段。这个字段不能设置primary_key和unique选项.在数据库中存储类型是varchar，默认最大长度为100. 有两个可选参数： upload_to: 如果使用默认的FileSystomStorage，文件将会存储到settings文件中配置的MEDIA_ROOT路径中。upload_to的值也可以为可调用对象,通过调用这个对象可以获得上传路径。 instance=: 定义了FileField的模型实例 filename='': 文件名称。 class MyModel01(models.Model): # file will be uploaded to MEDIA_ROOT/uploads upload = models.FileField(upload_to='uploads/') # or... # file will be saved to MEDIA_ROOT/uploads/2015/01/30 upload = models.FileField(upload_to='uploads/%Y/%m/%d/') #upload_to=可调用对象 def user_directory_path(instance, filename): # file will be uploaded to MEDIA_ROOT/user_&lt;id&gt;/&lt;filename&gt; return 'user_{0}/{1}'.format(instance.user.id, filename) class MyModel02(models.Model): upload = models.FileField(upload_to=user_directory_path) storage 用来设定文件存储仓库 FilePathField(path=None, match=None, recursive=False, max_length=100, **options) 这个字段的值被限制在系统上某个目录中的所有文件名集合中。有三个参数: path='': 该参数必需。上行所说的'某个目录’的绝对路径。Example: &quot;/home/images&quot;. match='pattern': 可选参数。格式是正则表达式。用来拣选符合匹配正则表达式的文件 recursive=True/False: 可选参数，默认为False。设定是否递归该目录下所有子目录的所有文件。 FilePathField(path=&quot;/home/images&quot;, match=&quot;foo.*&quot;, recursive=True) FloatField() 浮点字段，默认的表单窗口部件是NumberInput。和DecimalField经常混淆不清，FloatField在内部使用Python中的float对象，而DecimalField在内部使用Python中的decimal对象。 ImageField(upload_to=None, height_field=None, width_field=None, max_length=100, **options) 图像字段。继承了FileField的所有属性和方法。而且还能自动验证上传的对象是否为合法的图像。 IntegerField() 整型字段。 GenericIPAddressField(protocol='both', unpack_ipv4=False, **options) ip地址字段 protocol='both/ipv4/ipv6': 默认为both unpack_ipv4: 用处不大。 NullBooleanField() 类似于BooleanField，不同的是其允许值为null TextField() 与CharField类似，但一般用来存储体积较大的文本。 TimeField(auto_now=False, auto_now_add=False, **options)` 时间字段，其值为datetime.time实例 URLField(max_length=200, **options)URL字段, 类似于CharField`的子类，默认最大长度为200. UUIDField(**options)通用唯一标识字段，当不想用django默认设置的AutoField`字段时，可以用该字段代替。 关系字段 1. 一对一： 现在有很多一对一辅导班，也就是上课时，一个老师对应一个学生，一个学生对应一个老师 2. 多对一： 很多偏远山区的学校可能整个学校只有一个老师，这一个老师对应多个学生，所有的学生对应这一个老师 3. 多对多： 而我们则很幸福，学校里有许多老师，一个老师教习一科，学生有多个老师，老师有多个学生。 ForeignKey(othermodel, on_delete, **options) 用于多对一或者一对多或者外键字段: othermodel： 所关联的模型，'多' model使用外键关联 '一'model。 当所关联的模型为他自己时，使用'self'; 当引用的模型为其他app中的模型时，要加上app名称标签: 'app_name.model_name'; 数据库会自动在外键字段上创建索引，可以使用de_index=False关闭该功能。 on_delete： 当删除 &quot;一&quot; 模型对象时，django会根据该参数的值对与该对象相关联的其他对象(也就是 '多’)进行操作。 在django1.9以及之前的版本中，on_delete作为一个关键字参数。而在1.10则可以作为第二个参数 models.CASCADE： 默认为models.CASCADE 级联删除。当删除'一'时，'多’会被删除。比如： # mysite项目下名为polls的app中的models.py class follower(models.Model): name = models.CharField(max_length=200) menpai = models.ForeignKey('menpai', on_delete=models.CASCADE) #定义了models.CASCADE属性 def __str__(self): return self.name class menpai(models.Model): name = models.CharField(max_length=200) def __str__(self): return self.name #运行 python3 manager.py shell进入交互页面 &gt;&gt;&gt; from polls.models import follower,menpai &gt;&gt;&gt; m1=menpai(name='huashanpai') &gt;&gt;&gt; m1.save() &gt;&gt;&gt; m2=menpai(name='riyuejiao') &gt;&gt;&gt; m2.save() &gt;&gt;&gt; f1=follower(name='linghuchong',menpai=m1) &gt;&gt;&gt; f1.save() &gt;&gt;&gt; f2=follower(name='renwoxing',menpai=m2) &gt;&gt;&gt; f2.save() &gt;&gt;&gt; f1.menpai &lt;menpai: huashanpai&gt; &gt;&gt;&gt; m1.delete() (2, {'polls.menpai': 1, 'polls.follower': 1}) # 删除华山派时，将令狐冲也删除了 modles.PROTECT : 当删除一个具有外键关系的对象时，会引发一个异常，阻止删除该对象 models.SET_NULL: 设置删除对象所关联的外键字段为null。但字段的null属性必需为True models.SET_DEFAULT : 设置删除对象所关联的外键字段为默认的值。 models.SET(value)：设置删除对象所关联的对象的外键字段为value,value也可以是一个可调用函数。 from django.conf import settings from django.contrib.auth import get_user_model from django.db import models def get_sentinel_user(): return get_user_model().objects.get_or_create(username='deleted')[0] class MyModel(models.Model): user = models.ForeignKey( settings.AUTH_USER_MODEL, on_delete=models.SET(get_sentinel_user), ) models.DO_NOTHING: 不做任何操作 limit_choices_to: 限制该字段为选项形。格式：limit_choices_to={'is_staff': True}。值也可以为可调用函数。 def limit_pub_date_choices(): return {'pub_date__lte': datetime.date.utcnow()} limit_choices_to = limit_pub_date_choices related_name 设置从关联对象到自身的关系的名称，若值为'+' 则关联对象与自身无逆向关系。详解请看官方文档。举例： related_name的作用是在反向引用的时候，就是通过User去找Employee的时候，用User.user_employee，引文关键词叫：reverse accessor。 class Employee(generic.BO): user = models.OneToOneField(User,verbose_name=_(&quot;登录账户&quot;),blank=True,null=True,on_delete=models.CASCADE,related_name='user_employee') to_field 设置所关联对象的关联字段。默认为关联对象的主键字段。 OneToOneField和ForeignKey有什么区别 ManyToManyField(othermodel, **options) 多对多字段。 othermodel: 所关联的model名称; db_table: 多对多关系会在两个模型所对应的表中间创建一个'中间表’ ，将多对多转换为两个多对一，该选项为这个中间表设置名称。一般来说django会默认为中间表创建名称，但人们读起来可能搞不清楚究竟中间表关联到了哪里; related_name: 同多对一字段中的related_name; limite_choices_to: 同....; symmetrical: 当多对多关联对象为自身时可能会用到的参数。默认为True。a,b同属于person模型，person中的friends字段与自身设置了多对多关系，当该值设置为True时，django假定关系为对称，即：a是b的朋友，那么b也是a的朋友。设置为False时，django会强制为逆向关系创建描述信息; though: 不想让django自动创建中间表，手动创建中间表所对应的model，通过though指定对应的model名称; though_field: 当though参数被使用时，该参数才会有效。指定使用哪些中间模型字段来确立两个模型的多对多关系; OneToOneField(othermodel, on_delete, parent_link=False, **options) 一对一字段。 othermodel: ....... on_delete:........ related_name:........... 参考资料 Fail to POST OneToOneField with Django REST 参考 关联 关联未定义的Model 如果你要与某个尚未定义的model建立关联，就使用model的名称，而不是使用model对象本身。 class Book(models.Model): pub = models.ForeignKey('Publisher') 关联自身 可以与自身建立多对一或者一对一关系。 class People(models.Model): name=models.CharField(max_length=20) leader=models.ForeignKey('self',blank=True,null=True) class Person(models.Model): friends = models.ManyToManyField(&quot;self&quot;) //通过shell添加关系 &gt;&gt;&gt;p1.friends.add(p2,p3) 默认情况下，这种关联关系是对称的，如果person1是person2的朋友，那么person2也是person1的朋友，要查找person2的所有朋友可以直接使用person2.friends.all()。 如果要取消这种对称关系，可以将symmetrical设置为False： class Person2(models.Model): friends=models.ManyToManyField(&quot;self&quot;,symmetrical=False) 这样查询p3的朋友，就需要p3.person_set.all()了 反向名称related_name 反向名称用来从被关联字段指向关联字段。 class Book(models.Model): name=models.CharField(max_length=20) pub=models.ForeignKey(Publisher,related_name='pub') authors=models.ManyToManyField(Author,related_name='author') 这样用Publisher或者Author反向查询Book时可以用related_name了:publisher1.pub.all()或者author1.author.all()。 如果不想设置反向关心，则设置related_name为'+'或者以'+'结束。 user = models.ForeignKey(User, related_name='+') 如果有多个ManyToManyField指向同一个Model，这样反向查询FOO_set的时候就无法弄清是哪个ManyToManyField字段了，所以可以禁止反向关系： users = models.ManyToManyField(User, related_name='u+') referents = models.ManyToManyField(User, related_name='ref+') 参考 认证和权限 settings.py设置默认的认证方式和权限。 REST_FRAMEWORK = { # 全局，默认认证 'DEFAULT_AUTHENTICATION_CLASSES': ( 'rest_framework.authentication.SessionAuthentication', 'rest_framework.authentication.BasicAuthentication', # 'rest_framework.authentication.TokenAuthentication', ), # 全局，默认权限 'DEFAULT_PERMISSION_CLASSES': ( 'rest_framework.permissions.IsAuthenticated', ), } django-rest-auth django-rest-auth用户管理app，网址 用户管理 登陆 /rest-auth/login/ (POST) username email password Returns Token key 登出 /rest-auth/logout/ (POST) 重置密码 /rest-auth/password/reset/ (POST) email 确认密码 /rest-auth/password/reset/confirm/ (POST) uid token new_password1 new_password2 Note:uid和token是请求重置密码接口/rest-auth/password/reset/返回的 修改密码 /rest-auth/password/change/ (POST) new_password1 new_password2 old_password 查询用户信息 /rest-auth/user/ (GET, PUT, PATCH) username first_name last_name Returns pk, username, email, first_name, last_name 注册 /rest-auth/registration/ (POST) username password1 password2 email 确认 /rest-auth/registration/verify-email/ (POST) key 自定义用户认证 BaseAuthentication类： django rest-framework 通过BaseAuthentication 实现认证功能,无论是自定义的认证类还是rest-framework自带的认证类都应该继承BaseAuthentication.BaseAuthentication 中有两个方法authenticate和authenticate_header,其中authenticate方法必须实现 如果用户需要自定义认证方法则继承BaseAuthentication重写authenticate方法即可. 新建UserToken 修改models.py文件，增减UserToken类，其中UserInfo也可使用系统的User类，具体如下： from django.db import models class UserInfo(models.Model): user_type_choices = ( (1, '普通用户'), (2, 'VPI'), (3, 'SVPI'), ) user_type = models.IntegerField(choices=user_type_choices) username = models.CharField(max_length=32, unique=True) password = models.CharField(max_length=64) class UserToken(models.Model): user = models.OneToOneField('UserInfo', models.CASCADE) token = models.CharField(max_length=64) 构建认证代码 打开APP_DIR/utils/auth.py（若无，则新建该文件），将认证代码放入其中。 from rest_framework import exceptions from rest_framework.authentication import BaseAuthentication from app01 import models # 实现自定义的认证类 class Authtication(BaseAuthentication): def authenticate(self, request): # 这儿的 request 对象不是 django 原生的 request 而是 rest_framework 内部进行封装过的 request # 使用 request._request 调用 django 原生的 request 对象 token = request._request.GET.get('token') # 检查用户的 token 是否合法 token_obj = models.UserToken.objects.filter(token=token).first() if not token_obj: # rest_framework 会在内部捕捉这个异常并返回给用户认证失败的信息 raise exceptions.AuthenticationFailed('用户认证失败') # 在 rest_framework 内部会将这两个字段赋值给request以供后续调用 return (token_obj.user, token_obj) 修改views.py文件 from django.http import JsonResponse from rest_framework.views import APIView from app01.utils.auth import Authtication import hashlib import time # 生成 token 字符串 def md5(user): ctime = str(time.time()) m = hashlib.md5(bytes(user, encoding='utf-8')) m.update(bytes(ctime, encoding='utf-8')) return m.hexdigest() # 用户登录 class AuthView(APIView): def post(self, request): ret = {'code':1000, 'msg':None} try: user = request._request.POST.get('username') pwd = request._request.POST.get('password') obj = models.UserInfo.objects.filter(username=user, password=pwd).first() if not obj: ret['code'] = 1001 ret['msg'] = &quot;用户名或密码错误&quot; # 为登录用户创建token token = md5(user) #存在更新 不存在创建 models.UserToken.objects.update_or_create(user=obj, defaults={'token':token}) ret['token'] = token except: ret['code'] = 1002 ret['msg'] = '请求异常' return JsonResponse(ret) # 业务代码 class Order(APIView): # 注册自定义的认证类, 可以有多个, 从左到右进行认证匹配 authentication_classes = [Authtication,] def get(self, request): # request.user 这个值等于 Authtication 返回的元组的第一个值 # request.auth 这个值等于 Authtication 返回的元组的第二个值 ret = {'code':1000, 'msg':None, 'data':None} ret['data'] = '欢迎使用本系统' return JsonResponse(ret) rest_framework内置的认证类： BasicAuthentication # 基于浏览器实现的 Basic 认证, ftp 使用网页登录时使用的就是 Basic 认证 SessionAuthentication # 基于 django 的 user.is_active 进行认证 TokenAuthentication # 简单的基于 token 的认证 RemoteUserAuthentication # 简单的远程用户认证实现 可参考文档： Django 认证系统 配置全局生效的认证类和匿名用户： 自定义的认证类如果每次都在指定的类中使用authentication_classes指定,就有可能出现大量的重复代码。我们可以通过全局设置让指定的认证类对继承自APIView的所有类生效，修改settings.py文件。 REST_FRAMEWORK = { # 设置全局生效的认证类(可以有多个) # app01 为 django app 的名称 # utils 为 app 目录下面的 utils 目录(这个目录必须包含 __init__.py 文件) # auth 为 utils 目录下面的 auth.py 文件 # Authtication 为 auth.py 文件里面的 Authtication 类 # 这儿的设置其实就是使用 from ... import ... 的路径 'DEFAULT_AUTHENTICATION_CLASSES': [&quot;app01.utils.auth.Authtication&quot;,], #匿名用户配置 'UNAUTHENTICATED_USER': None, # 设置匿名用户的用户名, 默认为 AnonymousUser, 使用 request.user 查看 'UNAUTHENTICATED_TOKEN': None, # 设置匿名用户的 token, 默认为 None, 使用 request.auth 查看 } 指定View类不使用全局的认证类： 在不使用全局认证类的View类中添加authentication_classes = []或者``authentication_classes = ['xxxx']` # authentication_classes = [] 表示不使用认证 # authentication_classes = ['xxxx'], xxxx 表示当前类需要使用的认证类用于替换全局类 参考链接 错误 Django Rest Framework - “detail”: “Not found.”` 遇到的情况是url被其他路由拦截。 Django：CSRF Failed: CSRF token missing or incorrect 登陆成功后一直返回Django：CSRF Failed: CSRF token missing or incorrect其实不是跨域问题，而是Django自带的用户验证机制导致，为此我们需要在请求头重添加X-CSRFToken,步骤如下：将Postman返回的cookie中的csrftoken值复制到请求头中， KEY VALUE X-CSRFToken cookie中的token值 之后提交请求即可。 官网链接 简化django的八个python包 参考资料 数据查询 django queryset 实现基本的增删改查等。 Django QuerySet 方法梳理 常用 Django QuerySet Api django_filter 实现定制化的查询功能，可对不同字段进行精确和模糊查询。 pypy官网 官方文档 用django-filter实现高级搜索 外键 serializer 自动序列化外键时会遇到一些问题。 参考文献 DRF 3 - Creating Many-to-Many update/create serializer with though table DRF: Simple foreign key assignment with nested serializers? manytomany 保存方式 # 直接保存多对多关系 def create(self, validated_data): if validated_data.get('help_poor'): help_poor_datas = validated_data.pop('help_poor') activity_arrangement = ActivityArrangement.objects.create(**validated_data) for help_poor_data in help_poor_datas: help_poor = HelpPoor.objects.create(**help_poor_data) activity_arrangement.help_poor.add(help_poor) else: activity_arrangement = ActivityArrangement.objects.create(**validated_data) return activity_arrangement 数据库 数据库连接 django连接mongodb数据库 参考文献 Django MongoDB Engine mongo数据库官方文档 model migrate 问题 django migrate error: table 'xxx' already exists 多为移库后，库表与migration文件不符造成，可以使用以下命令解决。 python manage.py migrate --fake &lt;appname&gt; 参考文献 参考 stack over flow 数据库迁移 slqlite3迁移mysql 数据库的迁移方法针对不同数据库，如 SQLite3, MySQL, PostgreSQL 之间数据迁移方案，以及数据在不同机器上迁移方案 简单的数据导出与导入（简单的迁移） django 项目提供了一个导出的方法 python manage.py dumpdata, 不指定 appname时默认为导出所有的app python manage.py dumpdata [appname] &gt; appname_data.json 比如我们有一个项目叫mysite, 里面有一个app叫blog,我们想导出blog的所有数据 python manage.py dumpdata blog &gt; blog_dump.json 数据导入,不需要指定appname python manage.py loaddata blog_dump.json ! ! ! 注意: 使用该方法解决问题，缺少表时手动添加库表 备注：一些常用的 python manage.py dumpdata auth &gt; auth.json # 导出用户数据 优点：可以兼容各种支持的数据库，也就是说，以前用的是SQLite3，可以导出后，用这种方法导入到MySQL, PostgreSQL等数据库，反过来也可以。 缺点：数据量大的时候，速度相对较慢，表的关系比较复杂的时候可以导入不成功。 如果你运气好的话可能会导入完成，但是往往不那么顺利，原因如下： a) 我们在写models的时候如果用到CharField,就一定要写max_length,在sqlite3中是不检查这个最大长度的，你写最大允许长度为100，你往数据库放10000个，sqlite3都不报错，而且不截断数据的长度，这似乎是slite3的优点，但是也给从sqlite3导入其它数据库带来了困难,因为MySQL和PostgreSQL数据库都会检查最大长度，超出时就报错！ b) Django 自带的contentType会导致出现一些问题 用上面的方法只迁移一个app应该问题不大，但是如果有用户，用户组挂钩，事情往往变得糟糕！如果导入后没有对数据进行修改，你可以考虑重新导入，可能还要快一些，如果是手动在后台输入或者修改过，这种方法就不适用了 参考文献 自强学堂 问题 Django 2.0 SQLite3 to MySQL loaddata error: “The database backend does not accept 0 as a value for AutoField.” //For illustration in datadump_3-7-18.json: [ { //&lt;----- I GOT DELETED &quot;model&quot;: &quot;inventory.bike&quot;, //&lt;----- I GOT DELETED &quot;pk&quot;: 0, //&lt;----- I GOT DELETED &quot;fields&quot;: { //&lt;----- I GOT DELETED //... //&lt;----- I GOT DELETED } //&lt;----- I GOT DELETED }, //&lt;----- I GOT DELETED { &quot;model&quot;: &quot;inventory.bike&quot;, &quot;pk&quot;: 1, &quot;fields&quot;: { //... } }, { &quot;model&quot;: &quot;inventory.bike&quot;, &quot;pk&quot;: 2, &quot;fields&quot;: { //... } } ] stackoverflow 从view到viewset django使用View， django-rest-framework(概念篇)——apiview&amp;viewset 分页 在drf中对于数据的返回支持多种分页技巧，在官网中主要向我们介绍了PageNumberPagination、LimitOffsetPagination、CursorPagination。 配置全局分页 采用全局配置需要在配置文件中设置，例如将全局分页设置为PageNumberPagination，需要在base.py中添加如下配置： REST_FRAMEWORK = { 'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination', 'PAGE_SIZE': 100 } 单独设置分页 如果需要对每个视图进行单独配置，需要设置ModelViewSet中的pagination_class值，示例如下： class MachineRoomViewSet(viewsets.ModelViewSet): &quot;&quot;&quot; 机房操作视图 &quot;&quot;&quot; queryset = MachineRoom.objects.all() serializer_class = MachineRoomSerializer pagination_class = PageNumberPagination 修改分页风格 如果你需要修改分页风格 ，系需要重写分页类，然后设置你需要修改的属性。 class LargeResultsSetPagination(PageNumberPagination): page_size = 1000 page_size_query_param = 'page_size' max_page_size = 10000 class StandardResultsSetPagination(PageNumberPagination): page_size = 100 page_size_query_param = 'page_size' max_page_size = 1000 # 然后在视图中使用.pagination_class属性调用该自定义类 class BillingRecordsView(generics.ListAPIView): queryset = Billing.objects.all() serializer_class = BillingRecordsSerializer pagination_class = LargeResultsSetPagination # 或者是在设置中修改DEFAULT_PAGINATION_CLASS REST_FRAMEWORK = { 'DEFAULT_PAGINATION_CLASS': 'apps.core.pagination.StandardResultsSetPagination' } pageNumberPagination使用方法 这个分页样式接受请求查询参数中的一个数字页面号。 GET https://api.example.org/accounts/?page=4 响应对象 HTTP 200 OK { &quot;count&quot;: 1023 &quot;next&quot;: &quot;https://api.example.org/accounts/?page=5&quot;, &quot;previous&quot;: &quot;https://api.example.org/accounts/?page=3&quot;, &quot;results&quot;: [ … ] } Django-restframework Pagination（分页） Django-rest-framework pagination ","link":"https://harveywxia.github.io/post/django-rest-framework-shi-yong-bi-ji/"},{"title":"Hello Gridea","content":"👏 欢迎使用 Gridea ！ ✍️ Gridea 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... Github Gridea 主页 示例网站 特性👇 📝 你可以使用最酷的 Markdown 语法，进行快速创作 🌉 你可以给文章配上精美的封面图和在文章任意位置插入图片 🏷️ 你可以对文章进行标签分组 📋 你可以自定义菜单，甚至可以创建外部链接菜单 💻 你可以在 Windows，MacOS 或 Linux 设备上使用此客户端 🌎 你可以使用 𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌 或 Coding Pages 向世界展示，未来将支持更多平台 💬 你可以进行简单的配置，接入 Gitalk 或 DisqusJS 评论系统 🇬🇧 你可以使用中文简体或英语 🌁 你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力 🖥 你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步 🌱 当然 Gridea 还很年轻，有很多不足，但请相信，它会不停向前 🏃 未来，它一定会成为你离不开的伙伴 尽情发挥你的才华吧！ 😘 Enjoy~ ","link":"https://harveywxia.github.io/post/hello-gridea/"}]}